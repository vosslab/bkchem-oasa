#!/usr/bin/env python3
"""Generate per-theme PNG icon sets from SVG sources for BKChem toolbar.

Do not hand-edit PNGs. SVGs in pixmaps/src/ are source-of-record.
PNGs are build artifacts generated by this script.

Reads all .svg files from pixmaps/src/, applies SVG-level recoloring
for each non-light theme (replacing dark ink strokes/fills with theme
foreground colors), then rasterizes to PNG via rsvg-convert.

Per-icon overrides are read from pixmaps/icon_rules.yaml when present.

Example:
	source source_me.sh && python3 tools/generate_theme_icons.py
	source source_me.sh && python3 tools/generate_theme_icons.py --verbose
"""

# Standard Library
import os
import re
import sys
import glob
import shutil
import argparse
import colorsys
import tempfile
import subprocess

import yaml


# default icon size in pixels (square)
DEFAULT_ICON_SIZE = 32


#============================================
def parse_args() -> argparse.Namespace:
	"""Parse command-line arguments.

	Returns:
		argparse.Namespace: parsed arguments
	"""
	parser = argparse.ArgumentParser(
		description="Generate per-theme PNG icon sets from SVG sources.",
	)
	parser.add_argument(
		'-s', '--size', dest='icon_size', type=int, default=DEFAULT_ICON_SIZE,
		help=f"Icon size in pixels, square (default: {DEFAULT_ICON_SIZE})",
	)
	parser.add_argument(
		'-n', '--dry-run', dest='dry_run', action='store_true',
		help="List files that would be generated without writing",
	)
	parser.add_argument(
		'-v', '--verbose', dest='verbose', action='store_true',
		help="Print each conversion as it happens",
	)
	args = parser.parse_args()
	return args


#============================================
def find_rsvg_convert() -> str:
	"""Locate the rsvg-convert binary on the system.

	Returns:
		str: absolute path to rsvg-convert

	Raises:
		FileNotFoundError: if rsvg-convert is not installed
	"""
	path = shutil.which('rsvg-convert')
	if path:
		return path
	# common homebrew location on macOS
	brew_path = '/opt/homebrew/bin/rsvg-convert'
	if os.path.isfile(brew_path):
		return brew_path
	raise FileNotFoundError(
		"rsvg-convert not found. Install it with: brew install librsvg"
	)


#============================================
def get_repo_root() -> str:
	"""Get the repository root directory.

	Returns:
		str: absolute path to repository root
	"""
	result = subprocess.run(
		['git', 'rev-parse', '--show-toplevel'],
		capture_output=True, text=True,
	)
	if result.returncode == 0:
		return result.stdout.strip()
	# fallback: derive from script location
	return os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))


#============================================
def normalize_hex(color: str) -> str:
	"""Normalize a hex color to lowercase 6-digit form.

	Args:
		color: hex color string (e.g. '#000', '#FFF', '#e0e0e0')

	Returns:
		str: lowercase 6-digit hex (e.g. '#000000', '#ffffff')
	"""
	if not color or not color.startswith('#'):
		return color.lower() if color else color
	hex_part = color[1:]
	# expand 3-digit shorthand to 6-digit
	if len(hex_part) == 3:
		hex_part = hex_part[0] * 2 + hex_part[1] * 2 + hex_part[2] * 2
	return '#' + hex_part.lower()


#============================================
def hex_to_rgb(hex_color: str) -> tuple:
	"""Convert hex color to (r, g, b) floats in 0.0-1.0 range.

	Args:
		hex_color: normalized 6-digit hex color

	Returns:
		tuple: (r, g, b) floats
	"""
	h = hex_color.lstrip('#')
	r = int(h[0:2], 16) / 255.0
	g = int(h[2:4], 16) / 255.0
	b = int(h[4:6], 16) / 255.0
	return (r, g, b)


#============================================
def is_dark_ink(hex_color: str, lum_threshold: float = 0.35,
	sat_threshold: float = 0.3) -> bool:
	"""Determine if a hex color is dark ink suitable for recoloring.

	Dark ink is low-luminance and low-saturation (dark grey/black strokes).
	Colorful fills (green, blue, orange) are preserved.

	Args:
		hex_color: normalized 6-digit hex color
		lum_threshold: maximum luminance to count as dark (0.0 to 1.0)
		sat_threshold: maximum saturation to count as unsaturated (0.0 to 1.0)

	Returns:
		bool: True if the color is dark ink
	"""
	r, g, b = hex_to_rgb(hex_color)
	# sRGB luminance
	luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b
	if luminance >= lum_threshold:
		return False
	# HSL saturation
	_h, _l, s = colorsys.rgb_to_hls(r, g, b)
	if s >= sat_threshold:
		return False
	return True


#============================================
def load_icon_rules(pixmaps_dir: str) -> dict:
	"""Load per-icon override rules from icon_rules.yaml.

	Args:
		pixmaps_dir: path to the pixmaps directory

	Returns:
		dict: rules with 'defaults' and 'overrides' keys
	"""
	rules_path = os.path.join(pixmaps_dir, 'icon_rules.yaml')
	if not os.path.isfile(rules_path):
		return {
			'defaults': {
				'mode': 'ink_only',
				'luminance_threshold': 0.35,
				'saturation_threshold': 0.3,
			},
			'overrides': {},
		}
	with open(rules_path, 'r') as fh:
		rules = yaml.safe_load(fh)
	# ensure defaults exist
	if 'defaults' not in rules:
		rules['defaults'] = {
			'mode': 'ink_only',
			'luminance_threshold': 0.35,
			'saturation_threshold': 0.3,
		}
	if 'overrides' not in rules:
		rules['overrides'] = {}
	return rules


#============================================
def get_icon_params(icon_name: str, rules: dict) -> dict:
	"""Get recoloring parameters for a specific icon.

	Merges per-icon overrides with global defaults.

	Args:
		icon_name: icon filename stem (without extension)
		rules: loaded icon_rules dict

	Returns:
		dict: mode, luminance_threshold, saturation_threshold
	"""
	defaults = rules['defaults']
	overrides = rules.get('overrides') or {}
	icon_override = overrides.get(icon_name, {})
	if icon_override is None:
		icon_override = {}
	params = {
		'mode': icon_override.get('mode', defaults.get('mode', 'ink_only')),
		'luminance_threshold': icon_override.get(
			'luminance_threshold',
			defaults.get('luminance_threshold', 0.35),
		),
		'saturation_threshold': icon_override.get(
			'saturation_threshold',
			defaults.get('saturation_threshold', 0.3),
		),
	}
	return params


#============================================
def find_hex_colors_in_svg(svg_text: str) -> set:
	"""Extract all hex color values from SVG text.

	Finds colors in both attribute values (stroke="#333333") and
	CSS style properties (stroke:#000000).

	Args:
		svg_text: raw SVG file content

	Returns:
		set: normalized hex colors found
	"""
	# match 3-digit and 6-digit hex colors
	pattern = r'#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}'
	matches = re.findall(pattern, svg_text)
	colors = set()
	for m in matches:
		colors.add(normalize_hex(m))
	return colors


#============================================
def recolor_svg_text(svg_text: str, fg_color: str,
	lum_threshold: float = 0.35, sat_threshold: float = 0.3) -> str:
	"""Replace dark ink colors in SVG text with the theme foreground.

	Scans for hex color values in stroke/fill attributes and CSS style
	properties. Colors that are dark ink (low luminance + low saturation)
	are replaced with the theme foreground color.

	Args:
		svg_text: raw SVG file content
		fg_color: theme foreground hex color (e.g. '#e0e0e0')
		lum_threshold: luminance threshold for dark ink detection
		sat_threshold: saturation threshold for dark ink detection

	Returns:
		str: recolored SVG text
	"""
	fg_normalized = normalize_hex(fg_color)

	def replace_color(match):
		"""Replace a hex color if it is dark ink."""
		original = match.group(0)
		normalized = normalize_hex(original)
		if is_dark_ink(normalized, lum_threshold, sat_threshold):
			return fg_normalized
		return original

	# replace hex colors in the SVG
	pattern = r'#[0-9a-fA-F]{6}|#[0-9a-fA-F]{3}'
	result = re.sub(pattern, replace_color, svg_text)
	return result


#============================================
def convert_svg_to_png(
	rsvg_path: str, svg_path: str, png_path: str, size: int
) -> bool:
	"""Convert a single SVG file to PNG using rsvg-convert.

	Args:
		rsvg_path: path to rsvg-convert binary
		svg_path: input SVG file path
		png_path: output PNG file path
		size: icon size in pixels (square)

	Returns:
		bool: True if conversion succeeded
	"""
	result = subprocess.run(
		[rsvg_path, '-w', str(size), '-h', str(size), svg_path, '-o', png_path],
		capture_output=True, text=True,
	)
	if result.returncode != 0:
		print(f"  ERROR converting {os.path.basename(svg_path)}: {result.stderr.strip()}")
		return False
	return True


#============================================
def load_theme_fg_color(themes_dir: str, theme_name: str) -> str:
	"""Load the foreground color for icons from a theme YAML.

	Uses gui.toolbar_fg if present, otherwise derives from
	chemistry.default_line as a reasonable foreground for icons.

	Args:
		themes_dir: path to themes/ directory
		theme_name: theme key (filename stem)

	Returns:
		str: hex foreground color for icon strokes
	"""
	theme_path = os.path.join(themes_dir, theme_name + '.yaml')
	with open(theme_path, 'r') as fh:
		theme = yaml.safe_load(fh)
	gui = theme.get('gui', {})
	# prefer explicit toolbar_fg key
	if 'toolbar_fg' in gui:
		return gui['toolbar_fg']
	# fallback: chemistry default line color is a good proxy for icon color
	chem = theme.get('chemistry', {})
	if 'default_line' in chem:
		return chem['default_line']
	return '#e0e0e0'


#============================================
def should_generate_theme(themes_dir: str, theme_name: str) -> bool:
	"""Check if a theme needs recolored icons (non-light themes).

	Light theme uses the original SVG colors (dark strokes on transparent).
	Dark themes need recolored icons.

	Args:
		themes_dir: path to themes/ directory
		theme_name: theme key

	Returns:
		bool: True if the theme needs recolored icons
	"""
	theme_path = os.path.join(themes_dir, theme_name + '.yaml')
	with open(theme_path, 'r') as fh:
		theme = yaml.safe_load(fh)
	toolbar_bg = theme.get('gui', {}).get('toolbar', '#e0e0e0')
	normalized = normalize_hex(toolbar_bg)
	r, g, b = hex_to_rgb(normalized)
	luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b
	# dark toolbar means icons need recoloring
	return luminance < 0.5


#============================================
def generate_light_pngs(
	rsvg_path: str, svg_dir: str, png_dir: str,
	icon_size: int, verbose: bool = False
) -> tuple:
	"""Generate light theme PNGs from unmodified SVGs.

	Args:
		rsvg_path: path to rsvg-convert
		svg_dir: source SVG directory
		png_dir: output PNG directory
		icon_size: square icon size in pixels
		verbose: print each conversion

	Returns:
		tuple: (success_count, error_count)
	"""
	os.makedirs(png_dir, exist_ok=True)
	svg_files = sorted(glob.glob(os.path.join(svg_dir, '*.svg')))
	success = 0
	errors = 0
	for svg_path in svg_files:
		name = os.path.splitext(os.path.basename(svg_path))[0]
		png_path = os.path.join(png_dir, name + '.png')
		ok = convert_svg_to_png(rsvg_path, svg_path, png_path, icon_size)
		if ok:
			success += 1
			if verbose:
				print(f"  {name}.svg -> png/{name}.png")
		else:
			errors += 1
	return (success, errors)


#============================================
def generate_theme_pngs(
	rsvg_path: str, svg_dir: str, png_dir: str,
	fg_color: str, rules: dict,
	icon_size: int, verbose: bool = False
) -> tuple:
	"""Generate recolored theme PNGs from SVG sources.

	Creates temporary recolored SVGs, rasterizes them to PNG,
	then cleans up the temp files.

	Args:
		rsvg_path: path to rsvg-convert
		svg_dir: source SVG directory
		png_dir: output PNG directory
		fg_color: theme foreground hex color
		rules: icon rules dict with defaults and overrides
		icon_size: square icon size in pixels
		verbose: print each conversion

	Returns:
		tuple: (success_count, error_count, skip_count)
	"""
	os.makedirs(png_dir, exist_ok=True)
	svg_files = sorted(glob.glob(os.path.join(svg_dir, '*.svg')))
	success = 0
	errors = 0
	skipped = 0
	# use a temporary directory for recolored SVGs
	with tempfile.TemporaryDirectory(prefix='bkchem_icons_') as tmp_dir:
		for svg_path in svg_files:
			name = os.path.splitext(os.path.basename(svg_path))[0]
			png_path = os.path.join(png_dir, name + '.png')
			# get per-icon parameters
			params = get_icon_params(name, rules)
			mode = params['mode']
			if mode == 'none':
				# copy unmodified SVG (no recoloring)
				ok = convert_svg_to_png(rsvg_path, svg_path, png_path, icon_size)
				if ok:
					skipped += 1
					if verbose:
						print(f"  {name}.svg -> (skipped recoloring)")
				else:
					errors += 1
				continue
			# read and recolor SVG
			with open(svg_path, 'r') as fh:
				svg_text = fh.read()
			recolored_svg = recolor_svg_text(
				svg_text, fg_color,
				lum_threshold=params['luminance_threshold'],
				sat_threshold=params['saturation_threshold'],
			)
			# write temporary recolored SVG
			tmp_svg_path = os.path.join(tmp_dir, name + '.svg')
			with open(tmp_svg_path, 'w') as fh:
				fh.write(recolored_svg)
			# rasterize to PNG
			ok = convert_svg_to_png(rsvg_path, tmp_svg_path, png_path, icon_size)
			if ok:
				success += 1
				if verbose:
					print(f"  {name}.svg -> png-dark/{name}.png")
			else:
				errors += 1
	return (success, errors, skipped)


#============================================
def main():
	"""Generate per-theme PNG icon sets from SVG sources."""
	args = parse_args()

	# locate rsvg-convert
	rsvg_path = find_rsvg_convert()

	# resolve directories
	repo_root = get_repo_root()
	pixmaps_dir = os.path.join(
		repo_root, 'packages', 'bkchem-app', 'bkchem_data', 'pixmaps',
	)
	svg_dir = os.path.join(pixmaps_dir, 'src')
	themes_dir = os.path.join(
		repo_root, 'packages', 'bkchem-app', 'bkchem_data', 'themes',
	)

	if not os.path.isdir(svg_dir):
		print(f"SVG source directory not found: {svg_dir}")
		sys.exit(1)

	# count SVG sources
	svg_files = sorted(glob.glob(os.path.join(svg_dir, '*.svg')))
	if not svg_files:
		print(f"No SVG files found in {svg_dir}")
		sys.exit(1)

	# load icon rules
	rules = load_icon_rules(pixmaps_dir)

	print(f"Found {len(svg_files)} SVG sources in {svg_dir}")
	print(f"Icon size: {args.icon_size}x{args.icon_size}")
	print(f"Tool: {rsvg_path}")

	if args.dry_run:
		print("\nDry run -- no files will be written:")
		for svg_path in svg_files:
			name = os.path.splitext(os.path.basename(svg_path))[0]
			print(f"  {name}.svg -> {name}.png")
		return

	# step 1: generate light theme PNGs from unmodified SVGs
	light_png_dir = os.path.join(pixmaps_dir, 'png')
	print(f"\nGenerating light theme PNGs -> {light_png_dir}")
	light_ok, light_err = generate_light_pngs(
		rsvg_path, svg_dir, light_png_dir, args.icon_size, args.verbose,
	)
	print(f"  Light: {light_ok} converted, {light_err} errors")

	# step 2: generate PNGs for each non-light theme
	theme_files = sorted(glob.glob(os.path.join(themes_dir, '*.yaml')))
	for theme_path in theme_files:
		theme_name = os.path.splitext(os.path.basename(theme_path))[0]
		if theme_name == 'light':
			# light theme uses unmodified SVGs (already generated above)
			continue
		if not should_generate_theme(themes_dir, theme_name):
			print(f"\nSkipping '{theme_name}' theme (light toolbar, no recoloring needed)")
			continue
		fg_color = load_theme_fg_color(themes_dir, theme_name)
		theme_png_dir = os.path.join(pixmaps_dir, f'png-{theme_name}')
		print(f"\nGenerating '{theme_name}' theme PNGs -> {theme_png_dir}")
		print(f"  Foreground color: {fg_color}")
		t_ok, t_err, t_skip = generate_theme_pngs(
			rsvg_path, svg_dir, theme_png_dir, fg_color, rules,
			args.icon_size, args.verbose,
		)
		print(f"  {theme_name}: {t_ok} recolored, {t_skip} skipped, {t_err} errors")

	print("\nDone.")


if __name__ == '__main__':
	main()
